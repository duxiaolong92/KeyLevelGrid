这份需求规格说明书整合了所有深度讨论的逻辑，聚焦**双轨解耦架构**、**70% 动态止盈**、**均价利润保护**、**挂单冷却**与**水位状态机**。建议作为 V2.2.1 主规范使用。

---

# 需求规格说明书：Key Level Grid 智能网格系统 (V2.2.1)

## 1. 项目概述

本系统是一个基于支撑/阻力位的自适应网格策略，旨在通过“静态坐标系”捕捉波动，并利用“动态头寸管理”保护利润。

- **核心逻辑**：30% 浮动底仓锁定 + 70% 动态阶梯止盈。
- **执行架构**：全局对账守卫 (Recon) + 事件驱动响应 (Event) 的双轨制。

---

## 2. 核心参数配置 (Settings)

| 参数名 | 默认值 | 意义说明 |
| --- | --- | --- |
| `sell_quota_ratio` | 0.7 | **动态止盈比例**：保留 30% 为底仓，卖出总持仓的 70%。 |
| `min_profit_pct` | 0.005 | **利润护城河**：卖价必须高于持仓均价 0.5%，否则不挂单。 |
| `price_buffer_pct` | 0.002 | **挂单安全垫**：现价偏离网格线 0.2% 时才允许挂回买单。 |
| `base_amount_per_grid` | 0.01 | **标准网格单位**：每个支撑位固定买入数量（合约张数或币数，见 FR-UNIT）。 |
| `base_position_locked` | 0 | **底仓锁定**：固定底仓数量（可为 0）。 |
| `direction` | LONG | **交易方向**：仅支持只做多（LONG）。 |
| `recon_interval_sec` | 30 | Recon 对账周期（可动态调节）。 |
| `order_action_timeout_sec` | 10 | 挂/撤单超时，超时触发状态回收。 |

---

## 3. 核心分配算法 (FR-ALG)

### 3.1 理论应挂总量公式 (Total Sell Target)

系统在对账（Recon）和成交（Event）时，必须以此公式作为基准锚点：

$$Total\_Sell\_Qty = (Current\_Holdings - Base\_Position\_Locked) \times sell\_quota\_ratio$$

注：若系统未设置固定底仓（Base_Position_Locked = 0），则直接按总持仓比例计算。

### 3.2 阶梯卖单分配算法 (Waterfall Allocation)

系统采用“瀑布流填坑法”分配卖单。设 $Q_{rem}$ 为待分配的总额度，从现价上方最近阻力位 $P_{r1}$ 开始迭代。

算法逻辑：

1. 初始化：$Q_{rem} = Total\_Sell\_Qty$
2. 第一层级 ($P_{r1}$)：目标挂单量 $q_1 = \min(Q_{rem}, base\_amount\_per\_grid)$  
   执行挂单，更新余额：$Q_{rem} = Q_{rem} - q_1$
3. 后续层级 ($P_{rn}$)：只要 $Q_{rem} > 0$ 且存在更高水位：  
   目标挂单量 $q_n = \min(Q_{rem}, base\_amount\_per\_grid)$  
   执行挂单，更新余额：$Q_{rem} = Q_{rem} - q_n$
4. 尾差处理：若迭代结束 $Q_{rem}$ 仍有剩余（所有阻力位挂满但额度还有剩），将 $Q_{rem}$ 累加到最后一个阻力位。
5. 最小订单校验：若任意 $q_n < Exchange\_Min\_Qty$，则该订单向下合并到 $q_{n-1}$。

---

## 4. 数量口径与计价展示 (FR-UNIT)

### 4.1 统一口径
- 系统内部处理以**合约张数**为主口径；若交易所返回币数量，则先换算为合约张数。
- 外部展示（日志/Telegram）必须实时按 Ticker 价格换算为 **USDT 计价**。

### 4.2 换算规则
- 币数量 = 合约张数 × contractSize  
- USDT 价值 = 币数量 × 价格

---

## 5. 双轨制运行机制 (FR-LOOP)

### 5.1 轨道 A：全局对账守卫 (Recon Track)

周期性执行（30s-60s），确保最终一致性：

1. **买单同步**：
   - 检查现价下方所有预设支撑位。
   - 若水位状态为 `IDLE` 且满足 `Current_Price > Level * (1 + price_buffer_pct)`，立即补挂买单。

2. **卖单比例纠偏**：
   - 计算“已挂卖单总量”与“理论应挂总量 (Total_Sell_Qty)”的差值。
   - 若差值 > 1 个标准网格单位，按阻力位由近及远执行增量补单或减量撤单。

3. **均价利润校验**：
   - 检查所有已挂卖单。若卖价低于 `Avg_Entry_Price * (1 + min_profit_pct)`，说明均价移动使该单失效，执行撤单并寻找更高位的阻力位重排。

### 5.2 轨道 B：事件驱动响应 (Event Track)

WebSocket 实时触发，追求极速响应：

1. **买单成交 (On Buy Filled)**：
   - 更新内存中的持仓数量与**均价**。
   - 计算本次成交增量的卖出额度：  
     $\Delta Q_{sell\_inc} = \Delta Q_{buy} \times sell\_quota\_ratio$
   - 寻位补偿：优先寻找已有卖单但未挂满 `base_amount_per_grid` 的水位进行补齐；若全部挂满，则在下一个空阻力位挂出 $\Delta Q_{sell\_inc}$。

2. **卖单成交 (On Sell Filled)**：
   - 释放该层级状态。
   - 校验 `price_buffer_pct`，尝试在下方对应支撑位挂回买单。

---

## 6. 水位状态机定义 (FR-STATE)

### 6.1 状态定义

| 状态 | 含义 | 交易所表现 |
| --- | --- | --- |
| IDLE | 空闲状态 | 无挂单 |
| PLACING | 挂单中 | 正在调用 API |
| ACTIVE | 活跃中 | 有挂单 |
| FILLED | 已成交 | 订单消失，待逻辑处理 |
| CANCELING | 撤单中 | 正在调用 API |

### 6.2 状态迁移图 (State Transition)

```mermaid
stateDiagram-v2
    [*] --> IDLE
    IDLE --> PLACING : 触发补单
    PLACING --> ACTIVE : API确认成功
    PLACING --> IDLE : API失败
    ACTIVE --> FILLED : 收到成交信号
    ACTIVE --> CANCELING : 触发撤单
    CANCELING --> IDLE : API确认撤单
    FILLED --> IDLE : 逻辑处理完成
```

### 6.3 状态触发条件与迁移规则

1. **补单触发 (IDLE -> PLACING)**  
   - Recon Track 发现水位缺失且符合 `price_buffer_pct`  
   - Event Track 在卖单成交后，尝试在下方补回买单  
   - 动作：锁定该水位，发送 create_order

2. **成交确认 (ACTIVE -> FILLED)**  
   - WebSocket 捕获 FILLED  
   - 动作：更新 Total_Holdings，标记为 FILLED，进入事件响应

3. **撤单重排 (ACTIVE -> CANCELING)**  
   - Recon Track 判定不满足 `min_profit_pct`  
   - 动作：发送 cancel_order

4. **任务回收 (FILLED/CANCELING -> IDLE)**  
   - 反向挂单请求已发出或撤单确认  
   - 动作：解除锁定，恢复 IDLE

---

## 7. 冲突处理与防御规则 (FR-SYS)

### 7.1 冲突场景优先级

1. **水位刚成交 & Recon 到达**  
   - Event Track 优先  
   - Event 将水位设为 IDLE 后，Recon 扫描到 IDLE 即可补单（方向一致）

2. **均价剧烈变动触发 Recon 撤单重排**  
   - Recon Track 优先  
   - Recon 发起全局撤单时启用 GridLock  
   - Event 任务挂起，待 Recon 完成后继续补差

3. **API 权重不足 (Rate Limit)**  
   - Recon Track 挂起  
   - 优先保障 Event Track（实时补单）  
   - Recon 周期临时拉长至 `recon_interval_sec * 2`

### 7.2 冲突防御规则 (State Safety Guard)

- **读写互斥**：发起 create_order/cancel_order 前必须校验状态  
  - 买单：仅允许 IDLE  
  - 卖单：仅允许 ACTIVE  
- **僵尸状态清理**：PLACING/CANCELING 超过 `order_action_timeout_sec` 强制回收为 IDLE，并用实盘 API 校准  
- **最终一致性覆盖**：  
  - 实盘有单但状态为 IDLE -> 更新为 ACTIVE  
  - 实盘无单但状态为 ACTIVE -> 更新为 IDLE

### 7.3 止损机制保留

- 保留原全仓止损机制（交易所计划委托）。  
- 双轨系统不修改止损逻辑，仅在持仓与网格层面协作。

---

## 8. 状态持久化与多实例 (FR-SYS)

- **状态落地**：实时保存 `state/{instance_id}.json`，记录 GridMap 水位状态、订单 ID、持仓均价。  
- **重启恢复**：重启后先执行实盘 Position 同步，再启动 Recon 模块恢复挂单。  
- **多实例隔离**：1 交易所 + 1 币种 + 1 TG Bot = 1 独立进程，日志与环境变量独立。

---

## 9. 验收标准

1. **底仓保护验证**：无论价格如何上涨，系统持仓始终不低于初始买入总额的 30%（或配置比例）。  
2. **冷静期验证**：价格压在支撑线上时，系统应因 `price_buffer_pct` 拒绝挂单，直到价格拉开距离。  
3. **自愈性验证**：手动撤销交易所挂单，系统在 60 秒内通过 Recon 自动找回。  
4. **增量更新验证**：买单成交后仅执行“差值补偿”，不执行全量重分配。  